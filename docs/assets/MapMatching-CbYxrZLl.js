import{b$ as se,u as X,r as w,c0 as ne,w as oe,a as D,a8 as Y,ay as h,a9 as Z,br as le,_ as re,c as m,v as ie,o as ue,b as f,x as N,f as s,e as r,ae as ce,z as i,A as v,g as l,d as T,a$ as L,k as j,a7 as P,y as x,av as de,G as z,H,af as pe,P as fe,b1 as ve,a5 as me,a0 as he,a6 as be,I as U,B as K,C as Q,ag as ge,V as ye,O as ke}from"./index-CvyIjEju.js";const xe=se("runMapMatching",()=>{const{$gettext:G}=X(),o=w("arn:aws:states:ca-central-1:142023388927:stateMachine:quetzal-mapmatching-api"),e=w("quetzal-api-bucket"),d=w("");function _(){d.value=le()}const C=w([]),{error:B,running:p,errorMessage:F,startExecution:J,status:M,stopExecution:O}=ne(o.value),b=w({SIGMA:4.02,BETA:3,POWER:2,DIFF:!0,ptMetrics:!0});function V(c){c.forEach(u=>b.value[u.name]=u.value)}oe(M,async c=>{c==="SUCCEEDED"&&(p.value=!0,await g(),await S(),p.value=!1,M.value="",D().changeNotification({text:G("PT network successfully Mapmatched. See results pages for more details."),autoClose:!1,color:"success"}))});async function g(){const c=D();c.initLinks();const u=Y();u.unloadFiles();const y=await h.readJson(e.value,d.value.concat("/links_final.geojson"));u.appendNewLinks(y);const k=await h.readJson(e.value,d.value.concat("/nodes_final.geojson"));if(u.appendNewNodes(k),b.value.ptMetrics){c.initrLinks();const I=Z(),n=await h.readJson(e.value,d.value.concat("/road_links.geojson")),a=await h.readJson(e.value,d.value.concat("/road_nodes.geojson"));I.loadrLinks(n),I.loadrNodes(a)}}async function S(){let c=await h.listFiles(e.value,d.value);c=c.filter(y=>y.endsWith(".csv"));const u=[];for(const y of c){let k=y.split("/").slice(-1);k="outputs/"+k;const I=await h.readBytes(e.value,y);u.push({path:k,content:I})}u.length>0&&D().loadOtherFiles(u)}return{stateMachineArn:o,bucket:e,callID:d,exclusions:C,status:M,running:p,error:B,errorMessage:F,parameters:b,saveParams:V,setCallID:_,startExecution:J,stopExecution:O,getCSVs:S}}),_e={class:"background"},we={key:1,class:"text-grey text-caption align-self-center"},Me={__name:"MapMatching",setup(G){const{$gettext:o}=X(),e=xe(),d=Z(),_=Y(),C=m(()=>d.rlinksIsEmpty),B=m(()=>_.linksIsEmpty),p=m(()=>e.running),F=m(()=>e.status),J=m(()=>e.error),M=m(()=>e.errorMessage),O=m(()=>e.timer),b=m(()=>e.callID),V=m(()=>e.bucket),g=w(!1),S=w([{name:"SIGMA",text:"Sigma",value:e.parameters.SIGMA,type:"Number",units:"meters",hint:"emission probablity constant. the bigger it     is the further away a stops can be from roads."},{name:"BETA",text:"beta",value:e.parameters.BETA,type:"Number",units:"meters",hint:"transition probablity constant. The smaller the smaller      the difference between the as-the-crow and routing distance can be (if use difference is true)"},{name:"POWER",text:"power",value:e.parameters.POWER,type:"Number",units:"meters",hint:"Power used in the Emission Probability"},{name:"DIFF",text:"Use difference",value:e.parameters.DIFF,type:"Boolean",units:"bool",hint:"If False, act_dist is ignore in the transition probability. This change the emission to only     consider the shortest path between nodes. "},{name:"ptMetrics",text:"Add indicators on links",value:e.parameters.ptMetrics,type:"Boolean",units:"bool",hint:"Add PT metrics to road links (ex: number of trips & number of lines)"}]);ie(()=>{e.exclusions=e.exclusions.filter(n=>k.value.includes(n))}),ue(()=>{e.saveParams(S.value)});async function c(){e.running=!0,e.setCallID(),u(),await y();const n={callID:b.value,exclusions:e.exclusions};S.value.forEach(a=>{n[a.name]=a.value}),e.startExecution(n)}function u(){let a=_.tripId.length/6;function t(A,ee=20,te=[12,8,4,2,1]){let ae=Math.floor(A/ee),R=100,W=12;for(let $ of te){let q=Math.abs(ae-$);q<R&&(R=q,W=$)}return W}const E=t(a,20,[12,8,4,2,1]);e.timer=a/E+20+20+10}async function y(){const n=[];n.push(h.putObject(V.value,b.value.concat("/road_links.geojson"),JSON.stringify(d.rlinks))),n.push(h.putObject(V.value,b.value.concat("/road_nodes.geojson"),JSON.stringify(d.rnodes))),n.push(h.putObject(V.value,b.value.concat("/links.geojson"),JSON.stringify(_.links))),n.push(h.putObject(V.value,b.value.concat("/nodes.geojson"),JSON.stringify(_.nodes)));try{await Promise.all(n)}catch(a){D().changeAlert(a)}}const k=m(()=>Array.from(new Set(_.links.features.map(n=>n.properties.route_type))));function I(){e.stopExecution()}return(n,a)=>(f(),N("section",_e,[s(ke,{class:"card"},{default:r(()=>[s(ce,null,{default:r(()=>[i(v(l(o)("Match PT network on road network")),1)]),_:1}),C.value||B.value?(f(),T(L,{key:0},{default:r(()=>[i(v(l(o)("need a road and a PT network")),1)]),_:1})):j("",!0),s(P),a[5]||(a[5]=x("p",{class:"pl-4"},[i(" Emission = 0.5 x ( dist_to_road / SIGMA ) ^ POWER "),x("br"),i(" Transition = 1 / BETA x | dijkstra_dist - acf_dist* | "),x("br"),i(" Probablity = Emission + Transition "),x("br"),i(" * If use difference is true. Else acf_dist = 0 "),x("br")],-1)),s(P),s(L,null,{default:r(()=>a[3]||(a[3]=[i(" Hidden Markov Map Matching Through Noise and Sparseness "),x("br",null,null,-1),i(" Paul Newson and John Krumm 2009 ")])),_:1}),s(P),s(L,null,{default:r(()=>[J.value?(f(),T(de,{key:0,density:"compact",width:"50rem",variant:"outlined",text:"",type:"error"},{default:r(()=>[i(v(l(o)("There as been an error Mapmatching.             Please try again. If the problem persist, contact us."))+" ",1),(f(!0),N(z,null,H(Object.keys(M.value),t=>(f(),N("p",{key:t},[x("b",null,v(t)+": ",1),i(v(M.value[t]),1)]))),128))]),_:1})):j("",!0)]),_:1}),s(pe),s(P),s(fe,{modelValue:l(e).exclusions,"onUpdate:modelValue":a[0]||(a[0]=t=>l(e).exclusions=t),items:k.value,disabled:p.value,hint:g.value?l(o)("routes type to not mapmatch (ex subway are not on roads)"):"",label:"route_type exclusion",variant:"outlined",multiple:""},{selection:r(({item:t,index:E})=>[E<2?(f(),T(ve,{key:0},{default:r(()=>[x("span",null,v(t.title),1)]),_:2},1024)):j("",!0),E===2?(f(),N("span",we," (+"+v(l(e).exclusions.length-2)+" others) ",1)):j("",!0)]),_:1},8,["modelValue","items","disabled","hint"]),(f(!0),N(z,null,H(S.value,(t,E)=>(f(),N("div",{key:E,class:"items"},[t.type==="Boolean"?(f(),T(me,{key:0,modelValue:t.value,"onUpdate:modelValue":A=>t.value=A,class:"pr-2",color:"primary",disabled:p.value,label:l(o)(t.text),hint:g.value?l(o)(t.hint):"","persistent-hint":g.value},null,8,["modelValue","onUpdate:modelValue","disabled","label","hint","persistent-hint"])):(f(),T(he,{key:1,modelValue:t.value,"onUpdate:modelValue":A=>t.value=A,type:t.type,disabled:p.value,label:l(o)(t.text),suffix:t.units,hint:g.value?l(o)(t.hint):"","persistent-hint":g.value,required:"",onWheel:()=>{}},null,8,["modelValue","onUpdate:modelValue","type","disabled","label","suffix","hint","persistent-hint"]))]))),128)),s(be,null,{default:r(()=>[s(U,{variant:"outlined",color:"success",loading:p.value,disabled:p.value||C.value||B.value,onClick:c},{default:r(()=>[i(v(l(o)("Process")),1)]),_:1},8,["loading","disabled"]),K(s(U,{color:"grey",variant:"text",onClick:a[1]||(a[1]=t=>I())},{default:r(()=>[i(v(l(o)("Abort")),1)]),_:1},512),[[Q,p.value&&F.value==="RUNNING"]]),K(s(ge,null,{default:r(()=>[i(" ~ "+v(O.value>0?Math.ceil(O.value/60):l(o)("less than 1"))+v(l(o)(" minutes remaining")),1)]),_:1},512),[[Q,p.value]]),s(P),s(U,{size:"small",onClick:a[2]||(a[2]=t=>g.value=!g.value)},{default:r(()=>[s(ye,null,{default:r(()=>a[4]||(a[4]=[i("far fa-question-circle small")])),_:1})]),_:1})]),_:1})]),_:1})]))}},Se=re(Me,[["__scopeId","data-v-363751b2"]]);export{Se as default};
