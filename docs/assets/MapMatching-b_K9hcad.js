import{cj as ne,i as Q,r as w,ck as oe,w as le,u as O,h as Y,aU as y,f as Z,cl as re,_ as ie,e as h,o as ue,ag as ce,j as p,k as T,q as a,v as r,a6 as de,F as i,y as f,z as o,J as C,bc as U,K as F,B as P,aR as pe,L as z,M as H,m as k,R as fe,H as me,bd as he,aJ as ve,I as be,aa as ge,V as R,$ as K,a0 as X,al as ye,X as _e,T as ke,aC as xe,aD as we}from"./index-CIzcs_Se.js";const Me=ne("runMapMatching",()=>{const{$gettext:M}=Q(),n=w("arn:aws:states:ca-central-1:142023388927:stateMachine:quetzal-mapmatching-api"),e=w("quetzal-api-bucket"),m=w("");function x(){m.value=re()}const j=w([]),{error:B,running:d,errorMessage:J,startExecution:L,status:S,stopExecution:D}=oe(n.value),v=w({SIGMA:4.02,BETA:3,POWER:2,DIFF:!0,ptMetrics:!0});function V(c){c.forEach(u=>v.value[u.name]=u.value)}le(S,async c=>{c==="SUCCEEDED"&&(d.value=!0,await b(),await I(),d.value=!1,S.value="",O().changeNotification({text:M("PT network successfully Mapmatched. See results pages for more details."),autoClose:!1,color:"success"}))});async function b(){const c=O();c.initLinks();const u=Y();u.unloadFiles();const g=await y.readJson(e.value,m.value.concat("/links_final.geojson"));u.appendNewLinks(g);const _=await y.readJson(e.value,m.value.concat("/nodes_final.geojson"));if(u.appendNewNodes(_),v.value.ptMetrics){c.initrLinks();const N=Z(),s=await y.readJson(e.value,m.value.concat("/road_links.geojson"));N.loadrLinks(s)}}async function I(){let c=await y.listFiles(e.value,m.value);c=c.filter(g=>g.endsWith(".csv"));const u=[];for(const g of c){let _=g.split("/").slice(-1);_="outputs/"+_;const N=await y.readBytes(e.value,g);u.push({path:_,content:N})}u.length>0&&O().loadOtherFiles(u)}return{stateMachineArn:n,bucket:e,callID:m,exclusions:j,status:S,running:d,error:B,errorMessage:J,parameters:v,saveParams:V,setCallID:x,startExecution:L,stopExecution:D,getCSVs:I}}),ee=M=>(xe("data-v-363751b2"),M=M(),we(),M),Se={class:"background"},Ve=ee(()=>k("p",{class:"pl-4"},[i(" Emission = 0.5 x ( dist_to_road / SIGMA ) ^ POWER "),k("br"),i(" Transition = 1 / BETA x | dijkstra_dist - acf_dist* | "),k("br"),i(" Probablity = Emission + Transition "),k("br"),i(" * If use difference is true. Else acf_dist = 0 "),k("br")],-1)),Ie=ee(()=>k("br",null,null,-1)),Ee={key:1,class:"text-grey text-caption align-self-center"},Te={__name:"MapMatching",setup(M){const{$gettext:n}=Q(),e=Me(),m=Z(),x=Y(),j=h(()=>m.rlinksIsEmpty),B=h(()=>x.linksIsEmpty),d=h(()=>e.running),J=h(()=>e.status),L=h(()=>e.error),S=h(()=>e.errorMessage),D=h(()=>e.timer),v=h(()=>e.callID),V=h(()=>e.bucket),b=w(!1),I=w([{name:"SIGMA",text:"Sigma",value:e.parameters.SIGMA,type:"Number",units:"meters",hint:"emission probablity constant. the bigger it     is the further away a stops can be from roads."},{name:"BETA",text:"beta",value:e.parameters.BETA,type:"Number",units:"meters",hint:"transition probablity constant. The smaller the smaller      the difference between the as-the-crow and routing distance can be (if use difference is true)"},{name:"POWER",text:"power",value:e.parameters.POWER,type:"Number",units:"meters",hint:"Power used in the Emission Probability"},{name:"DIFF",text:"Use difference",value:e.parameters.DIFF,type:"Boolean",units:"bool",hint:"If False, act_dist is ignore in the transition probability. This change the emission to only     consider the shortest path between nodes. "},{name:"ptMetrics",text:"Add indicators on links",value:e.parameters.ptMetrics,type:"Boolean",units:"bool",hint:"Add PT metrics to road links (ex: number of trips & number of lines)"}]);ue(()=>{e.exclusions=e.exclusions.filter(s=>_.value.includes(s))}),ce(()=>{e.saveParams(I.value)});async function c(){e.running=!0,e.setCallID(),u(),await g();const s={callID:v.value,exclusions:e.exclusions};I.value.forEach(l=>{s[l.name]=l.value}),e.startExecution(s)}function u(){let l=x.tripId.length/6;function t(A,te=20,ae=[12,8,4,2,1]){let se=Math.floor(A/te),G=100,W=12;for(let q of ae){let $=Math.abs(se-q);$<G&&(G=$,W=q)}return W}const E=t(l,20,[12,8,4,2,1]);e.timer=l/E+20+20+10}async function g(){const s=[];s.push(y.putObject(V.value,v.value.concat("/road_links.geojson"),JSON.stringify(m.rlinks))),s.push(y.putObject(V.value,v.value.concat("/road_nodes.geojson"),JSON.stringify(m.rnodes))),s.push(y.putObject(V.value,v.value.concat("/links.geojson"),JSON.stringify(x.links))),s.push(y.putObject(V.value,v.value.concat("/nodes.geojson"),JSON.stringify(x.nodes)));try{await Promise.all(s)}catch(l){O().changeAlert(l)}}const _=h(()=>Array.from(new Set(x.links.features.map(s=>s.properties.route_type))));function N(){e.stopExecution()}return(s,l)=>(p(),T("section",Se,[a(ke,{class:"card"},{default:r(()=>[a(de,null,{default:r(()=>[i(f(o(n)("Match PT network on road network")),1)]),_:1}),j.value||B.value?(p(),C(U,{key:0},{default:r(()=>[i(f(o(n)("need a road and a PT network")),1)]),_:1})):F("",!0),a(P),Ve,a(P),a(U,null,{default:r(()=>[i(" Hidden Markov Map Matching Through Noise and Sparseness "),Ie,i(" Paul Newson and John Krumm 2009 ")]),_:1}),a(P),a(U,null,{default:r(()=>[L.value?(p(),C(pe,{key:0,density:"compact",width:"50rem",variant:"outlined",text:"",type:"error"},{default:r(()=>[i(f(o(n)("There as been an error Mapmatching.             Please try again. If the problem persist, contact us."))+" ",1),(p(!0),T(z,null,H(Object.keys(S.value),t=>(p(),T("p",{key:t},[k("b",null,f(t)+": ",1),i(f(S.value[t]),1)]))),128))]),_:1})):F("",!0)]),_:1}),a(fe),a(P),a(me,{modelValue:o(e).exclusions,"onUpdate:modelValue":l[0]||(l[0]=t=>o(e).exclusions=t),items:_.value,disabled:d.value,hint:b.value?o(n)("routes type to not mapmatch (ex subway are not on roads)"):"",label:"route_type exclusion",variant:"outlined",multiple:""},{selection:r(({item:t,index:E})=>[E<2?(p(),C(he,{key:0},{default:r(()=>[k("span",null,f(t.title),1)]),_:2},1024)):F("",!0),E===2?(p(),T("span",Ee," (+"+f(o(e).exclusions.length-2)+" others) ",1)):F("",!0)]),_:1},8,["modelValue","items","disabled","hint"]),(p(!0),T(z,null,H(I.value,(t,E)=>(p(),T("div",{key:E,class:"items"},[t.type==="Boolean"?(p(),C(ve,{key:0,modelValue:t.value,"onUpdate:modelValue":A=>t.value=A,class:"pr-2",color:"primary",disabled:d.value,label:o(n)(t.text),hint:b.value?o(n)(t.hint):"","persistent-hint":b.value},null,8,["modelValue","onUpdate:modelValue","disabled","label","hint","persistent-hint"])):(p(),C(be,{key:1,modelValue:t.value,"onUpdate:modelValue":A=>t.value=A,type:t.type,disabled:d.value,label:o(n)(t.text),suffix:t.units,hint:b.value?o(n)(t.hint):"","persistent-hint":b.value,required:"",onWheel:()=>{}},null,8,["modelValue","onUpdate:modelValue","type","disabled","label","suffix","hint","persistent-hint"]))]))),128)),a(ge,null,{default:r(()=>[a(R,{variant:"outlined",color:"success",loading:d.value,disabled:d.value||j.value||B.value,onClick:c},{default:r(()=>[i(f(o(n)("Process")),1)]),_:1},8,["loading","disabled"]),K(a(R,{color:"grey",variant:"text",onClick:l[1]||(l[1]=t=>N())},{default:r(()=>[i(f(o(n)("Abort")),1)]),_:1},512),[[X,d.value&&J.value==="RUNNING"]]),K(a(ye,null,{default:r(()=>[i(" ~ "+f(D.value>0?Math.ceil(D.value/60):o(n)("less than 1"))+f(o(n)(" minutes remaining")),1)]),_:1},512),[[X,d.value]]),a(P),a(R,{size:"small",onClick:l[2]||(l[2]=t=>b.value=!b.value)},{default:r(()=>[a(_e,null,{default:r(()=>[i("far fa-question-circle small")]),_:1})]),_:1})]),_:1})]),_:1})]))}},Ae=ie(Te,[["__scopeId","data-v-363751b2"]]);export{Ae as default};
